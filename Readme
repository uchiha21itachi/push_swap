ARG=`ruby -e "puts (0..3).to_a.shuffle.join(' ')"`; ./push_swap $ARG | ./checker -v $ARG


ARG=`ruby -e "puts (0..3).to_a.join(' ')"`; valgrind --leak-check=full --show-leak-kinds=definite --track-origins=yes  --read-var-info=yes ./a.out $ARG


length of stack and number of operations on average :

3 == 5 (max 5)

5 == 11 (max 12)

100 == 833 (max 900)

500 == 7900 (max 8500)
















https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a


/*
    if (stackA->num > stackA->next->num)
        swapA;
    if (stackA->num > ft_lstlast(stackA))
        rra;
        sa; 
                            2
                            0
                            1

if (stackA->num > stackA->next->num)
        swapA;
if (stackA->num < ft_last;
    ra;
    sa
    rra
    
*/










    // // while (data->min <= data->med)
    // // {
    // //     while (data->min_pos != 1)
    // //     {
    // //        if (data->min_pos > (stackA->length / 2))
    // //             exec("RRA", stackA, stackB);
    // //         else
    // //             exec("RA", stackA, stackB);
    // //         get_min_pos(stackA->node, data);
    // //     }
    // //     exec("PB", stackA, stackB);
    // //     update_min(stackA->node, data);
    // //     printf("NEW -> min [%d] min pos [%d]\n",data->min, data->min_pos);
    // // }
    // // while (data->min_pos != 1)
    // // {
    // //     if (data->min_pos > (stackA->length / 2))
    // //         exec("RRA", stackA, stackB);
    // //     else
    // //         exec("RA", stackA, stackB);
    // //     get_min_pos(stackA->node, data);

    // // }
    // while (stackB->length != 0)
    //     exec("PA", stackA, stackB);







